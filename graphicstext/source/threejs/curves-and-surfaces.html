<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Three.js Curves and Surfaces</title>

<!--
   This page can show several 3D objects that are created using
   three.js support for curves and surfaces. A popup menu lets the
   user select different "worlds", each showing one or two objects.
-->


<script type="importmap">
  {
     "imports": {
        "three": "./script/three.module.min.js",
        "addons/": "./script/"
     }
  }
</script>
<script type="module">
import * as THREE from "three";
import {ParametricGeometry} from "addons/geometries/ParametricGeometry.js";
import {TrackballControls} from "addons/controls/TrackballControls.js";

let canvas, scene, renderer, camera;  // Basic three.js requirements.
      // Note: In this program, a new scene and camera are created for
      // each of the  "worlds".
      
let controls;  // TrackballControls for rotating the view.

/* Runs an animation that renders the scene in each frame.
 * The animation is needed to support the use of TrackballControls.
 * This function is called just once, in the init() method.
 */
function animate() {
    controls.update();
    renderer.render(scene,camera);
    requestAnimationFrame(animate);
}



/* A function for creating a parametric surface.  The function takes two numbers, u and v,
 * and a Vector3 as parameters.  It modifies the vector by setting its x,y,z coordinates
 * to represent the point on the surface generated by the given values of u and v.
 * When used to create a ParametricGeometry, the function will be called for
 * values of u and v ranging from 0.0 to 1.0. 
 */
function surfaceFunction( u, v, vector ) {
    let x,y,z;  // Coordinates for a point on the surface, calculated from u,v,
                // where u and v range from 0 to 1.
    x = 20 * (u - 0.5);  // x and z range from -10 to 10
    z = 20 * (v - 0.5);
    y = 2*(Math.sin(x/2) * Math.cos(z));
    vector.set( x, y, z );
}


/*  Creates a scene to show a parametric surface.  The surface is defined by the
 *  previous function, surfaceEquation().
 */
function createWorld1() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(35,canvas.width/canvas.height,0.1,100);
    camera.position.set(0,0,40);
    
    let light = new THREE.DirectionalLight(0xffffff, 0.3);
    light.position.set(0,0,1);
    camera.add(light);  // Viewpoint light moves with camera.
    scene.add(camera);
    
    light = new THREE.PointLight(0xffffff, 0.5);  // A light shining from above the surface.
    light.position.set(0,20,0);
    scene.add(light);
    
    /* Create the geometry. The 2nd and 3rd parameters are the number of subdivisions in
     * the u and v directions, respectively.
     */
    let surfaceGeometry = new ParametricGeometry(surfaceFunction, 64, 64);

    let material = new THREE.MeshPhongMaterial({
        color: "white",
        specular: 0x444444,
        side: THREE.DoubleSide
    });
    
    let surface = new THREE.Mesh( surfaceGeometry, material );
    scene.add(surface);
    
}



/*  Creates a scene that shows two objects created using THREE.TubeGeometry.
 *  A tube is created around a 3D curve.  In this case, the curve is a helix.
 *  Both tubes use the same curve; only the radius of the tube is different.
 */
function createWorld2() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(50,canvas.width/canvas.height,0.1,100);
    camera.position.set(0,0,60);
    let light = new THREE.DirectionalLight(0xffffff, 0.7);
    light.position.set(0,0,1);  // Light moves with the camera.
    camera.add(light);
    scene.add(camera);
    
    scene.add(new THREE.AmbientLight(0x333333)); // For more even illumination.
    
    let material = new THREE.MeshPhongMaterial({
        color: "white",
        specular: 0x444444,
        side: THREE.DoubleSide
    });
    
    /* Create a curve object.  A THREE.Curve needs a "getPoint" function to
     * define the curve.  The parameter to getPoint() is a number that ranges
     * from 0.0 to 1.0.  The return value is a vector.  It can return THREE.Vector2
     * for a curve in the xy-plane, or THREE.Vector3 for a 3D curve. In this
     * case, the function defines a helix that wraps around the y-axis.
     */
    let helix = new THREE.Curve();
    helix.getPoint = function(t) {
       let s = (t - 0.5) * 12*Math.PI;  
          // As t ranges from 0 to 1, s ranges from -6*PI to 6*PI, for 6 turns of the helix.
       return new THREE.Vector3(
            5*Math.cos(s),
            s,
            5*Math.sin(s)
       );
    };
    
    /* The parameters are:  (1) a THREE.Curve to define the curve; the geometry is a
     * tube with the curve running along the center of the tube; (2) the number of
     * segments of the tube along the length of the curve; (3) the radius of the
     * tube; (3) the number of segments around the cirumference of the tube.
     * The two tubes have radius 2.5 and 1 respectively.
     */
    let tubeGeometry1 = new THREE.TubeGeometry(helix,128,2.5,32);
    let tube1 = new THREE.Mesh( tubeGeometry1, material );
    tube1.position.x = 10; // Move to the right, to separate the two tubes for viewing.
    scene.add(tube1);
    
    let tubeGeometry2 = new THREE.TubeGeometry(helix,128,1,32);
    let tube2 = new THREE.Mesh( tubeGeometry2, material );
    tube2.position.x = -10; // Move to the left, to separate the two tubes for viewing.
    scene.add(tube2);
    
}


/*  Creates a scene that shows an object that is created by "lathing".  That is,
 *  a surface is generated by taking a curve the lies in the xz-plane and rotating
 *  it around the y-axis.  A copy of the curve is also shown, moved 5 units away
 *  from the surface so that it can be seen.  For viewing, the combined objects
 *  are rotated so that in the initial view, the axis of the lathed object lies
 *  along the x-axis.
 */
function createWorld3() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(30,canvas.width/canvas.height,0.1,100);
    camera.position.set(0,0,50);
    let light = new THREE.DirectionalLight(0xffffff, 0.6);
    light.position.set(0,0,1);
    camera.add(light); // "Viewpoint" light moves with camera.
    scene.add(camera);
    
    scene.add(new THREE.AmbientLight(0x202020)); // extra light for more even illumination
    
    let material = new THREE.MeshPhongMaterial({
        color: "white",
        specular: 0x333333,
        side: THREE.DoubleSide
    });
    
    /*  Create a cosine curve in the xy-plane to define the points for the lathe.  We could
     *  define an array of points directly, but it's nice to use a THREE.Curve to do it.
     *  The curve is defined by a the function x = 3 + 2*cos(z)
     */
    let cosine = new THREE.Curve();
    cosine.getPoint = function(t) {
       t = (t - 0.5) * 7*Math.PI;
       return new THREE.Vector2( 3 + 2*Math.cos(t), t );
    };
    
    
    /*  A lathed object is created using an array of points. The points should should be THREE.Vector2
     *  and represent a curve in the xy-plane.  In this case, cosine.getPoints(128) produces an array 
     *  of 128 points that lie along the curve.  The lines connecting the points are rotated about the y-axis to
     *  generate a surface. The second parameter is the number of radial subdivisions of the surface.
     */
    let points = cosine.getPoints(128);
    let latheGeometry = new THREE.LatheGeometry(points, 32);
    let lathe = new THREE.Mesh(latheGeometry, material);
    scene.add(lathe);
    
    
    /* I also make a basic line geometry from the same array of points, adding a z-coordinate equal to zero.
     * This would lie along the surface, but I move it 6 units to the right to make it visible.
     */
    let curveVertices = [];
    for (let pt of points) {
       curveVertices.push( pt.x, pt.y, 0 );
    }
    let curveGeom = new THREE.BufferGeometry();
    curveGeom.setAttribute("position", new THREE.BufferAttribute(new Float32Array(curveVertices), 3) );
    let curve = new THREE.Line(curveGeom, new THREE.LineBasicMaterial({ color:0xffffff, linewidth:2 }));
    curve.position.x = 6;
    lathe.add(curve);

    lathe.rotation.z = Math.PI/2;    
    
}





/*  Creates a scene that shows a THREE.ShapeGeometry object and two THREE.ExtrudeObject.
 *  Both are created from a THREE.Shape, which defines a closed 2D path lying in the xy-plane.
 *  The ShapeGeometry simply fills in the interior of the path to make a planar shape.
 *  The ExtrudeGeometry creates a solid object by "extruding" the shape into the third
 *  dimension.  One of the ExtrudeGeometry objects has a "bevel," which means that its
 *  sharp edges are cut off (Actuall, the shape is padded rather than cut.)
 */
function createWorld4() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(50,canvas.width/canvas.height,0.1,100);
    camera.position.set(0,0,70);
    let light = new THREE.DirectionalLight(0xffffff, 0.7);
    light.position.set(0,0,1);  //"Viewpoint light" moves with the camera.
    camera.add(light);
    scene.add(camera);
    
    scene.add(new THREE.AmbientLight(0x222222));  // To make the illumination more even.
    
    let material = new THREE.MeshPhongMaterial({
        color: "white",
        specular: 0x202020,
        side: THREE.DoubleSide
    });
    
    /*  Create a path.  A THREE.Shape has methods for defining a path in 2D that are similar
     *  to the ones used in the HTML canvas 2D graphics API:  moveTo(x,y), lineTo(x,y),
     *  quadraticCurveTo(cx,cy,x,y), and bezierCurveTo(c1x,c1y,c2x,c2y,x,y).  (These functions
     *  are defined in THREE.Path, which is the superclass of THREE.Shape.)  Note that
     *  a shape can be composed of several disconnected segments, and that it can have holes.
     *  Here, I make a very simple "teardrop" shape.
     */
    let path = new THREE.Shape();
    path.moveTo(0,10);
    path.bezierCurveTo( 0,5, 20,-10, 0,-10 );
    path.bezierCurveTo( -20,-10, 0,5, 0,10 );
    
    /* Create a 2D shape in the xy-plane by filling in the path.
     */
    let shapeGeom = new THREE.ShapeGeometry( path );
    let shape = new THREE.Mesh(shapeGeom, material);
    shape.position.x = -25;  // Move to the left
    scene.add(shape);
    
    /* Create a 3D shape by extruding the path by 6 units in the z-direction, with a bevel.
     */
    let extrudeGeom1 = new THREE.ExtrudeGeometry( path, {
       curveSegments: 32,  // How many points on each part of the path
       depth: 6,          // size in the 3rd dimension; how far to extrude.
       bevelSize: 1,       
       bevelThickness: 1
    });
    let extrude1 = new THREE.Mesh(extrudeGeom1, material);
    extrude1.position.z = -3; // Move so center is at the origin.
    scene.add(extrude1);
    
    /* Same as the previous shape, but without a bevel.
     */
    let extrudeGeom2 = new THREE.ExtrudeGeometry( path, {
       curveSegments: 32,
       depth: 6,
       bevelEnabled: false  // Don't bevel the edges
    });
    let extrude2 = new THREE.Mesh(extrudeGeom2, material);
    extrude2.position.x = 25;  // Move to the right
    extrude2.position.z = -3;  // Move so center is at the origin.
    scene.add(extrude2);
}



/*  This page uses TrackballControls to let the user use the mouse to rotate
 *  the view.  TrackballControls are designed to be used during an animation, even
 *  though in this case the scene only changes when the user is rotating the
 *  object.  (But the animation lets the object slow to a halt after the user
 *  stops dragging, instead of stopping abruptly.)
 */
function installTrackballControls() { 
    controls = new TrackballControls(camera,canvas);
    controls.noPan = true;
    controls.noZoom = true;
}


/* This function is called when the user changes the selection of the
 * "world" popup menu.  It calls the corresponding function createWorld1(),
 * createWorld2(), createWorld3(), or createWorld4().
 */
function changeWorld() {
    let worldNum = Number(document.getElementById("world").value);
    switch (worldNum) {
        case 1: createWorld1(); break;
        case 2: createWorld2(); break;
        case 3: createWorld3(); break;
        case 4: createWorld4(); break;
    }
    controls.reset();  // return TrackballControls rotation to zero.
    controls.object = camera;  // Make trackball use the camera for the new world
}


function init() {
    try {
        canvas = document.getElementById("maincanvas");
        renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true
        });
        renderer.setClearColor("black");
    }
    catch (e) {
        document.getElementById("canvas-holder").innerHTML=
             "<p><b>Sorry, an error occurred:<br>" + e + "</b></p>";
        return;
    }
    document.getElementById("world").value = "1";
    document.getElementById("world").onchange = changeWorld;
    createWorld1();
    installTrackballControls();
    animate();
}

window.onload = init;  // Arranges for init() to be called when the page has been loaded.

</script>
</head>
<body>

    
<h2>Three.js Curves and Surfaces Examples</h2>
    
<p><b>Use your mouse (or finger) to rotate the scene.</b></p>

<p><label><b>Select Example: </b><select id="world">
    <option value="1">Parametric Surface</option>
    <option value="2">Tube Geometry</option>
    <option value="3">Lathe Geometry</option>
    <option value="4">Shape and Extrude Geometries</option>
</select></label>

<div id="canvas-holder">
<canvas id="maincanvas" width="600" height="500"></canvas>
</div>

</body>
</html>
