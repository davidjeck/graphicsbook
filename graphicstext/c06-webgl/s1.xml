<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section SYSTEM "../graphicstext.dtd" >

<section title="The Programmable Pipeline" id="webgl.1">

<p1>OpenGL 1.1 uses a <newword>fixed-function pipeline</newword> for graphics processing.
Data is provided by a program and passes through a series of processing stages that ultimately
produce the pixel colors seen in the final image.  The program can enable and disable
some of the steps in the process, such as the <word>depth test</word> and <word>lighting</word>
calculations.  But there is no way for it to change what happens at each stage.  The functionality
is fixed.</p1>

<p>OpenGL 2.0 introduced a <newword>programmable pipeline</newword>.  It became possible
for the programmer to replace certain stages in the pipeline with their own programs.
This gives the programmer complete control over what happens at that stage.  In OpenGL 2.0,
the programmability was optional; the complete fixed-function pipeline was still available
for programs that didn't need the flexibility of programmability.  WebGL uses a programmable
pipeline, and it is <b>mandatory</b>.  There is no way to use WebGL without writing
programs to implement part of the graphics processing pipeline.</p>

<p>The programs that are written as part of the pipeline are called <newword term="shader">shaders</newword>.
For WebGL, you need to write a <newword>vertex shader</newword>, which is called once for
each vertex in a <word term="geometric primitive">primitive</word>, and a 
<newword>fragment shader</newword>, which is called once for each
pixel in the primitive.  Aside from these two programmable stages,
the WebGL pipeline also contains several stages from the original fixed-function pipeline.
For example, the depth test is still part of the fixed functionality, and it can be enabled or
disabled in WebGL in the same way as in OpenGL&nbsp;1.1.</p>

<p>In this section, we will cover the basic structure of a WebGL program and how data
flows from the JavaScript side of the program into the graphics pipeline and through
the vertex and fragment shaders.</p>

<p>I should note that later versions of OpenGL have introduced
new programmable stages, in addition to the vertex and fragment shaders,
but they are not part of WebGL 1.0 or 2.0, and they are not covered in this book.</p>


<subsection title="The WebGL Graphics Context" id="webgl.1.1">

<p>To use WebGL, you need a WebGL graphics context.  The graphics context is a JavaScript object
whose methods implement the JavaScript side of the WebGL API.
WebGL draws its images in an <word>HTML canvas</word>, the same kind of <tag>canvas</tag> element
that is used for the 2D API that was covered in <localref href="graphics2d.6"/>. A graphics
context is associated with a particular canvas.  A graphics context for WebGL 1.0 can 
be obtained by calling the function
<i>canvas.getContext</i>("webgl"), where <i>canvas</i> is a <word>DOM</word> object
representing the canvas.  For WebGL 2.0, you would simply use <i>canvas.getContext</i>("webgl2")
instead.  The return value of <i>getContext</i>() will be <i>null</i> if the context
cannot be created.  So, getting a WebGL graphics context often looks something like this:</p>

<pre>canvas = document.getElementById("webglcanvas");
gl = canvas.getContext("webgl");  // or maybe canvas.getContext("webgl2")
if ( ! gl ) {
    throw new Error("WebGL not supported; can't create graphics context.");
}</pre>

<np>Here, the first line gets a reference to the HTML canvas that WebGL
will used throughout the program for drawing. The name <i>gl</i> for the
variable is up to you, but I will always use <i>gl</i> for the WebGL graphics 
context in my discussion.  This code assumes that the HTML source
for the web page includes a canvas element with id=&leftquote;webglcanvas", such as</np>

<pre>&lt;canvas width="800" height="600" id="webglcanvas"&gt;&lt;/canvas&gt;</pre>


<p>In the second line of the above code, 
<i>canvas.getContext</i>("webgl") will return <i>null</i>
if the web browser does not support "webgl" as a parameter to <i>getContext</i>.
Since <i>null</i> is considered to be <i>false</i> in JavaScript when used in
a <i>boolean</i> context, the third line tests whether the return value is <i>null</i>.
In that case, the code throws an error, which can be handled elsewhere, probably
by showing an error message to the user. Furthermore, the code will throw an exception if
the browser has no support at all for <tag>canvas</tag>.  My programs often
use an initialization function of the form</p>

<pre>function init() {
    try {
        canvas = document.getElementById("webglcanvas");
        gl = canvas.getContext("webgl");  // or "webgl2"
        if ( ! gl ) {
            throw new Error("WebGL not supported.");
        }
    }
    catch (e) {
          .
          .  // report the error
          .
        return;
    }
    initGL();  // a function that initializes the WebGL graphics context
      .
      .  // other JavaScript initialization
      .
}</pre>

<np>In this function, <i>canvas</i> and <i>gl</i> are global variables. And 
<i>initGL</i>() is a function defined elsewhere in the script 
that initializes the graphics context, including
creating and installing the shader programs.  The <i>init</i>() function should
be called when the page is loaded.  This can be arranged, for example, by
assigning "window.onload = init;" in the script.</np>

<p>Once the graphics context, <i>gl</i>, has been created, it can be used to call
functions in the WebGL API.  For example, the command for enabling the depth
test, which was written as <i>glEnable</i>(<i>GL_DEPTH_TEST</i>) in OpenGL,
becomes</p>

<pre>gl.enable( gl.DEPTH_TEST );</pre>

<np>Note that both functions and constants in the API are referenced through the
graphics context.  The name "gl" for the graphics context is conventional, but remember that
it is just an ordinary JavaScript variable whose name is up to the programmer.</np>

<p>(Some very old browsers required <i>canvas.getContext</i>("experimental-webgl") to create
a WebGL 1.0 context.  This includes Internet Explorer&nbsp;11, but at this point,
no one should be using Internet Explorer.)</p>

</subsection>


<subsection title="The Shader Program" id="webgl.1.2">

<p>Drawing with WebGL requires a shader program, which consists of a vertex shader and
a fragment shader.  Shaders are written in some version of the <word>GLSL</word> programming language. 
WebGL 1.0 used GLSL ES 1.00, while WebGL 2.0 can use either GLSL ES 1.00 or GLSL ES 3.00.
The discussion here is about GLSL ES 1.00; I will explain some of the changes in the
3.00 version later.</p>
 
<p>GLSL is based on the C programming
language.  The vertex shader and fragment shader are separate programs, each with its own
<i>main</i>() function.  The two shaders are compiled separately and then "linked" to produce
a complete shader program.  The JavaScript API for WebGL includes functions for compiling
the shaders and then linking them.  To use the functions, the source code for the shaders
must be JavaScript strings.  Let's see how it works.  It takes three steps to create the
vertex shader.</p>

<pre>let vertexShader = gl.createShader( gl.VERTEX_SHADER );
gl.shaderSource( vertexShader, vertexShaderSource );
gl.compileShader( vertexShader );</pre>

<np>The functions that are used here are part of the WebGL graphics context, <i>gl</i>,
and the parameter <i>vertexShaderSource</i> is the string that contains the source code for the
shader.  Errors in the source code will cause the compilation to fail silently.
You need to check for compilation errors by calling the function
</np>

<pre>gl.getShaderParameter( vertexShader, gl.COMPILE_STATUS )</pre>

<np>which returns a boolean value to indicate whether the compilation succeeded. In
the event that an error occurred, you can retrieve an error message with</np>

<pre>gl.getShaderInfoLog( vertexShader )</pre>

<np>which returns a string containing the result of the compilation.  (The exact format
of the string is not specified by the WebGL standard.  The string is meant to be
human-readable.)</np>

<p>The fragment shader can be created in a similar way.  With both shaders in hand,
you can create and link the program.  The shaders need to be "attached" to the
program object before linking.  The code takes the form:</p>

<pre>let prog = gl.createProgram();
gl.attachShader( prog, vertexShader );
gl.attachShader( prog, fragmentShader );
gl.linkProgram( prog );</pre>

<p>Even if the shaders have been successfully compiled, errors can occur when they
are linked into a complete program.  For example, the vertex and fragment shader
can share certain kinds of variable.  If the two programs declare such variables with the same name but
with different types, an error will occur at link time.   Checking for link errors
is similar to checking for compilation errors in the shaders.</p>

<p>The code for creating a shader program is always pretty much the same, so it is
convenient to pack it into a reusable function.  Here is the function that I use for
the examples in this chapter:</p>

<pre>/**
 * Creates a program for use in the WebGL context gl, and returns the
 * identifier for that program.  If an error occurs while compiling or
 * linking the program, an exception of type Error is thrown.  The error
 * string contains the compilation or linking error. 
 */
function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
   let vsh = gl.createShader( gl.VERTEX_SHADER );
   gl.shaderSource( vsh, vertexShaderSource );
   gl.compileShader( vsh );
   if ( ! gl.getShaderParameter(vsh, gl.COMPILE_STATUS) ) {
      throw new Error("Error in vertex shader:  " + gl.getShaderInfoLog(vsh));
   }
   let fsh = gl.createShader( gl.FRAGMENT_SHADER );
   gl.shaderSource( fsh, fragmentShaderSource );
   gl.compileShader( fsh );
   if ( ! gl.getShaderParameter(fsh, gl.COMPILE_STATUS) ) {
      throw new Error("Error in fragment shader:  " + gl.getShaderInfoLog(fsh));
   }
   let prog = gl.createProgram();
   gl.attachShader( prog, vsh );
   gl.attachShader( prog, fsh );
   gl.linkProgram( prog );
   if ( ! gl.getProgramParameter( prog, gl.LINK_STATUS) ) {
      throw new Error("Link error in program:  " + gl.getProgramInfoLog(prog));
   }
   return prog;
}</pre>

<p>There is one more step:  You have to tell the WebGL context to use the program.
If <i>prog</i> is a program identifier returned by the above function, this is done
by calling</p>

<pre>gl.useProgram( prog );</pre>

<np>It is possible to create several shader programs.  You can then switch from one
program to another at any time by calling <i>gl.useProgram</i>, even in the middle of
rendering an image.  (<i>Three.js</i>, for example, uses a different program for each
type of <classname>Material</classname>.)</np>

<p>It is advisable to create any shader programs that you need as part of initialization.
Although <i>gl.useProgram</i> is a fast operation, compiling and linking are rather slow,
so it's better to avoid creating new programs while in the process of drawing an image.</p>

<p>Shaders and programs that are no longer needed can be deleted to free up the resources
they consume. Use the functions <i>gl.deleteShader</i>(<i>shader</i>) and
<i>gl.deleteProgram</i>(<i>program</i>).</p>

</subsection>

<subsection title="Data Flow in the Pipeline" id="webgl.1.3">

<p>The WebGL graphics pipeline renders an image.  The data that defines the image
comes from JavaScript.  As it passes through the pipeline, it is processed by 
the current vertex shader and fragment shader as well as by the fixed-function
stages of the pipeline.  You need to understand how data is placed by JavaScript
into the pipeline and how the data is processed as it passes through the pipeline.</p>

<p>The basic operation in WebGL is to draw a <word>geometric primitive</word>.
WebGL uses just seven of the OpenGL primitives that were introduced in
<localref href="gl1geom.1.1"/>.  The primitives for drawing <word term="quad">quads</word>
and <word term="polygon">polygons</word> have been removed.  The remaining primitives draw
points, line segments, and triangles.  In WegGL, the seven types of primitive are identified by
the constants <i>gl.POINTS</i>, <i>gl.LINES</i>, <i>gl.LINE_STRIP</i>, <i>gl.LINE_LOOP</i>,
<i>gl.TRIANGLES</i>, <i>gl.TRIANGLE_STRIP</i>, and <i>gl.TRIANGLE_FAN</i>, where 
<i>gl</i> is a WebGL graphics context.</p>

<p>When WebGL is used to draw a primitive, there are two general categories of data
that can be provided for the primitive.  The two kinds of data are referred to
as <newword term="attribute variable">attribute variables</newword> 
(or just "attributes") and <newword term="uniform variable">uniform variables</newword>
(or just "uniforms").  A primitive is defined by its type and by a list of <word term="vertex">vertices</word>.
The difference between attributes and uniforms is that a uniform variable has a single value
that is the same for the entire primitive, while the value of an attribute variable can
be different for different vertices.</p>

<p>One attribute that should always be specified is the coordinates of the vertex.  
The vertex coordinates must be an attribute since each vertex
in a primitive will have its own set of coordinates.  Another possible attribute is color.
We have seen that OpenGL allows you to specify a different color for each vertex of
a primitive.  You can do the same thing in WebGL, and in that case the color will be an
attribute.  On the other hand, maybe you want the entire primitive to have the same,
"uniform" color; in that case, color can be a uniform variable.  Other quantities
that could be either attributes or uniforms, depending on your needs, include
<word term="normal vector">normal vectors</word> and <word term="material">material properties</word>.
<word term="texture coordinates">Texture coordinates</word>, if they are used,
are almost certain to be an attribute, since it doesn't really make sense for
all the vertices in a primitive to have the same texture coordinates.  If a 
<word>geometric transform</word> is to be applied to the primitive, it would naturally
be represented as a uniform variable.</p>

<p>It is important to understand, however, that WebGL does not come with <b>any</b>
predefined attributes, not even one for vertex coordinates.  In the programmable pipeline, the attributes and uniforms
that are used are entirely up to the programmer.  As far as WebGL is concerned,
attributes are just values that are passed into the vertex shader.  Uniforms
can be passed into the vertex shader, the fragment shader, or both.  WebGL does not
assign a meaning to the values.  The meaning is entirely determined by what the shaders
do with the values.  The set of attributes and uniforms that are used in drawing a
primitive is determined by the source code of the shaders that are in use
when the primitive is drawn.</p>

<p>To understand this, we need to look at what happens in the pipeline in a more detail.
When drawing a primitive, the JavaScript program specifies values for any attributes
and uniforms in the shader program.  For each attribute, it will specify an array of values,
one for each vertex.  For each uniform, it will specify a single value.  It must
send these values to the to the <word>GPU</word> before drawing the primitive. 
The primitive can then be drawn by calling a single JavaScript function.  At that
point, the GPU takes over, and executes the shader programs. When drawing the primitive,
the GPU calls the vertex shader once for each vertex.  The attribute values for the vertex
that is to be processed 
are passed as input into the vertex shader.  Values of uniform variables are also passed 
to the vertex shader.  The way this works is that both attributes and uniforms are represented as
global variables in the vertex shader program.  Before calling the shader for a given vertex,
the GPU sets the values of those variables appropriately for that specific vertex.</p>

<p>As one of its outputs, the vertex shader must specify the coordinates of the vertex in 
the <word term="clip coordinates">clip coordinate system</word> (see <localref href="gl1geom.3.1"/>).
It does that by assigning a value to a special variable named <i>gl_Position</i>.
The position is often computed by applying a transformation to the
attribute that represents the coordinates in the <word term="object coordinates">object coordinate system</word>,
but exactly how the position is computed is up to the programmer.</p>

<p>After the positions of all the vertices in the primitive have been computed,
a fixed-function stage in the pipeline clips away the parts of the primitive whose coordinates
are outside the range of valid clip coordinates (&minus;1 to 1 along each coordinate axis).
The primitive is then <word term="rasterization">rasterized</word>; that is, it is
determined which pixels lie inside the primitive. The GPU then calls the fragment shader once for
each pixel that lies in the primitive.  The fragment shader has access to uniform variables
(but not attributes).  It can also use a special variable named <i>gl_FragCoord</i>
that contains the clip coordinates of the pixel.  Pixel coordinates are computed
by <word term="interpolation">interpolating</word> the values of <i>gl_Position</i>
that were specified by the vertex shader.  The interpolation is done by another fixed-function 
stage that comes between the vertex shader and the fragment shader.
</p>

<p>Other quantities besides coordinates can work in much that same way.  That is, the vertex shader
computes a value for the quantity at each vertex of a primitive.  An interpolator takes the values
at the vertices and computes a value for each pixel in the primitive.  The value for a given
pixel is then input into the fragment shader when the shader is called to process that pixel.
For example, color in OpenGL follows this pattern: The color of an interior pixel of a primitive
is computed by interpolating the color at the vertices.  In GLSL, this
pattern is implemented using <newword term="varying variable">varying variables</newword>.</p>

<p>A varying variable is declared both in the vertex shader and in the fragment shader.
The vertex shader is responsible for assigning a value to the varying variable.  Each
vertex of a primitive can assign a different value to the variable.
The interpolator takes all the values produced by executing the vertex shader for 
each vertex of the primitive,  and it interpolates those values to produce a value for each
pixel.  When the fragment shader is executed for a given pixel, the value of the varying variable
is the interpolated value for that pixel.  The fragment shader can use the value in its
own computations.</p>

<p>Varying variables exist to communicate data from the vertex shader to the fragment shader.
They are defined in the shader source code.  They are not used or referred to in the
JavaScript side of the API.  Note that it is entirely up to the programmer to decide 
what varying variables to define and what to do with them.</p>

<p>We have almost gotten to the end of the pipeline.  After all that, the job of the
fragment shader is simply to specify a color for the pixel.  It does that by assigning
a value to a special variable named <i>gl_FragColor</i>.  That value will then
be used in the remaining fixed-function stages of the pipeline.</p>

<p>To summarize:  The JavaScript side of the program sends values for attributes and
uniform variables to the GPU and then issues a command to draw a primitive.  The GPU
executes the vertex shader once for each vertex.  The vertex shader can use the values
of attributes and uniforms. It assigns values to <i>gl_Position</i> and to any
varying variables that exist in the shader.  After clipping, rasterization, and interpolation, the
GPU executes the fragment shader once for each pixel in the primitive.  The fragment
shader can use the values of varying variables, uniform variables, and <i>gl_FragCoord</i>.
It computes a value for <i>gl_FragColor</i>.  This diagram summarizes the flow
of data:</p>

<img src="webgl-dataflow.png" width="281" height="476" tex="webgl-dataflow.eps" texscale="0.75"/>

<np>The diagram is not complete.  There are a few more special variables that I haven't mentioned.  
And there is the
important question of how <word term="texture">textures</word> are used.  
But if you understand the diagram, you have a good
start on understanding WebGL.</np>

<break/>

<p><b>For GLSL ES 3.00</b>, the same diagram applies, except that there is no
special variable <i>gl_FragColor</i>.  Instead, the fragment shader must define
its own output variable to represent the color.  In GLSL ES 1.00, 
the words "attribute" and "varying" are
used when declaring variables in the actual shader program source code.  In source code for the
3.00 version, attribute variables become "in" variables, since they are inputs
to the vertex shader, and varying variables become "out" variables in the
vertex shader and "in" variables in the fragment shader.  And the variable
<i>gl_FragColor</i> is replaced by an "out" variable in the fragment shader.
The use of the terms "in" and "out" are actually more appropriate to systems with
additional pipeline stages, where "out" variables from one stage can become "in" variables
to the next stage.  In any case, people still use the terms attribute and varying 
when discussing WebGL, even if it is using GLSL&nbsp;ES&nbsp;3.00.</p>

</subsection>


<subsection title="Values for Uniform Variables" id="webgl.1.4">

<p>It's time to start looking at some actual WebGL code. We will concentrate on the
JavaScript side first, but you need to know a little about GLSL.  GLSL has some
familiar basic data types: <ptype>float</ptype>, <ptype>int</ptype>, and
<ptype>bool</ptype>.  But it also has some new predefined data types to represent
<word term="vector">vectors</word> and <word term="matrix">matrices</word>.
For example, the data type <i>vec3</i> represents a vector in 3D.  The value of
a <i>vec3</i> variable is a list of three floating-point numbers.  Similarly,
there are data types <i>vec2</i> and <i>vec4</i> to represent 2D and 4D vectors.</p>

<p>Global variable declarations in a vertex shader can be marked as <i>attribute</i>,
<i>varying</i>, or <i>uniform</i> (or as <i>in</i>, <i>out</i>, or <i>uniform</i> in
GLSL ES 3.00, but again, we will stick to the 1.00 version for the time being). 
A variable declaration with none of these modifiers
defines a variable that is local to the vertex shader.  Global variables in a
fragment can optionally be <i>uniform</i> or <i>varying</i>, or they
can be declared without a modifier.  A varying variable should
be declared in both shaders, with the same name and type.  This allows the GLSL
compiler to determine what attribute, uniform, and varying variables are used in 
a shader program.</p>

<p>The JavaScript side of the program needs a way to refer to particular attributes
and uniform variables.  The function <i>gl.getUniformLocation</i>
can be used to get a reference to a uniform variable in a shader program, where <i>gl</i>
refers to the WebGL graphics context.  It takes
as parameters the identifier for the compiled program, which was returned by <i>gl.createProgram</i>,
and the name of the uniform variable in the shader source code.  For example,
if <i>prog</i> identifies a shader program that has a uniform variable named <i>color</i>, then
the location of the <i>color</i> variable can be obtained with the JavaScript statement
</p>

<pre>colorUniformLoc = gl.getUniformLocation( prog, "color" );</pre>

<np>The location <i>colorUniformLoc</i> can then be used to set the value of the
uniform variable. For example:</np>

<pre>gl.uniform3f( colorUniformLoc, 1, 0, 0 );</pre>

<np>The function <i>gl.uniform3f</i> is one of a family of functions that can be
referred to as a group as <i>gl.uniform*</i>.  This is similar to the family <i>glVertex*</i> in
OpenGL&nbsp;1.1.  The <i>*</i> represents a suffix that tells the number and type of
values that are provided for the variable.  In this case, <i>gl.uniform3f</i> takes
three floating point values, and it is appropriate for setting the value of a
uniform variable of type <i>vec3</i>.  The number of values can be 1, 2, 3, or 4.
The type can be "f" for floating point or "i" for integer.  (For a boolean uniform,
you should use <i>gl.uniform1i</i> and pass 0 to represent <i>false</i> or 
1 to represent <i>true</i>.)  If a "v" is added to the suffix, then the values
are passed in an array.  For example,</np>

<pre>gl.uniform3fv( colorUniformLoc, [ 1, 0, 0 ] );</pre>

<np>There is another family of functions for setting the value of uniform matrix
variables.  We will get to that later.</np>

<p>The value of a uniform variable can be set any time after the shader
program has been compiled, and the value remains in effect until it is changed
by another call to <i>gl.uniform*</i>.</p>

<p>If the string that is passed as the second parameter <i>gl.getUniformLocation</i>
is not the name of a uniform variable in the shader programs, then the return value
is <i>null</i>. The return value can also be <i>null</i> if the uniform variable is declared in
the shader source code but is not "active" in the program. A variable that is declared but not
actually used is not active, and it does not get a location in the compiled program.
This has occasionally caused problems for me, when I commented out part of 
a shader program for debugging purposes, and accidentally made a variable inactive
by doing so.</p>

</subsection>



<subsection title="Values for Attributes" id="webgl.1.5">

<p>Turning now to attributes, the situation is more complicated, because an attribute can take a
different value for each vertex in a primitive.  The basic idea is that the complete set of data 
for the attribute is copied in a single operation from a JavaScript array into memory that is 
accessible to the GPU.  Unfortunately, setting things up to make that operation possible is non-trivial.</p>

<p>First of all, a regular JavaScript array is not suitable for this purpose.  For efficiency, we need
the data to be in a block of memory holding numerical values in successive memory locations, and
regular JavaScript arrays don't have that form.  To fix this problem, a new kind of array,
called <word term="typed array">typed arrays</word>, was introduced into JavaScript.  We encountered
typed arrays when working with <word>three.js</word> in the <localref href="threejs"/>.
There is a short introduction to typed arrays in <localref href="threejs.1.3"/>.
A typed array has a fixed length, 
which is assigned when it is created, and it can only hold numbers of a specified type.  
There are different kinds of typed array for different
kinds of numerical data.  For now we will use  <classname>Float32Array</classname>,
which holds 32-bit floating point numbers. Once you have a typed array, 
you can use it much like a regular array, but
when you assign any value to an element of a <classname>Float32Array</classname>, the value is
converted into a 32-bit floating point number.  If the value cannot be interpreted as a number,
it will be converted to <i>NaN</i>, the "not-a-number" value.</p>

<p>Before data can be transferred from JavaScript into an attribute variable, it must be placed
into a typed array.  When possible, for efficiency, you should work with typed arrays directly, rather than working
with regular JavaScript arrays and then copying the data into typed arrays.</p>

<break/>

<p>For use in WebGL, the attribute data must be transferred into a <word>VBO</word> (vertex buffer 
object).  VBOs were introduced in OpenGL&nbsp;1.5 and were discussed briefly in <localref href="gl1geom.4.4"/>.
A&nbsp;VBO is a block of memory that is accessible to the GPU.  To use a VBO, you must first call
the function <i>gl.createBuffer</i>() to create it.  For example,</p>

<pre>colorBuffer = gl.createBuffer();</pre>

<np>Before transferring data into the VBO, you must "bind" the VBO:</np>

<pre>gl.bindBuffer( gl.ARRAY_BUFFER, colorBuffer );</pre>

<np>The first parameter to <i>gl.bindBuffer</i> is called the "target."  It specifies how the VBO will
be used. The target <i>gl.ARRAY_BUFFER</i> is used when the buffer is being used to store values
for an attribute.   Only one VBO at a time can be bound to a given target.</np>

<p>The function that transfers data into
a VBO doesn't mention the VBO&mdash;instead, it uses the VBO that is currently bound.
To copy data into that buffer, use <i>gl.bufferData</i>(). For example:</p>

<pre>gl.bufferData(gl.ARRAY_BUFFER, colorArray, gl.STATIC_DRAW);</pre>

<np>The first parameter is, again, the target.  The data is transferred into the VBO that
is bound to that target.  The second parameter is the typed array that holds the data on the JavaScript side.
All the elements of the array are copied into the buffer, and the size of the array determines
the size of the buffer.  Note that this is a straightforward transfer of raw data bytes; WebGL
does not remember whether the data represents floats or ints or some other kind of data.</np>

<p>The third parameter to <i>gl.bufferData</i> is one of the constants
<i>gl.STATIC_DRAW</i>, <i>gl.STREAM_DRAW</i>, or <i>gl.DYNAMIC_DRAW</i>.  It is
a hint to WebGL about how the data will be used, and it helps WebGL to manage the
data in the most efficient way.  The value <i>gl.STATIC_DRAW</i> means that you intend to
use the data many times without changing it.  For example, if you will use the same
data throughout the program, you can load it into a buffer once, during initialization,
using <i>gl.STATIC_DRAW</i>.  WebGL will probably store the data on the graphics card
itself where it can be accessed most quickly by the graphics hardware.  The second value,
<i>gl.STEAM_DRAW</i>, is for data that will be used only once, or at most a few times.  (It can be
"streamed" to the card when it is needed.)  The value <i>gl.DYNAMIC_DRAW</i> is somewhere
between the other two values; it is meant for data that will be used multiple times, but
with modifications.</p>

<break/>

<p>Getting attribute data into VBOs is only part of the story.  You also have to tell WebGL to
use the VBO as the source of values for the attribute.  To do so, first of all, you need
to know the location of the attribute in the shader program.  You can determine that
using <i>gl.getAttribLocation</i>.  For example,</p>

<pre>colorAttribLoc = gl.getAttribLocation(prog, "a_color");</pre>

<np>This assumes that <i>prog</i> is the shader program and "a_color" is the name of the
attribute variable in the vertex shader.  This is entirely analogous to <i>gl.getUniformLocation</i>
(except that the return value is an integer, and is -1 if the requested attribute does not
exist or is not active).</np>

<p>Although an attribute usually takes different values at different vertices, it is possible to
use the same value at every vertex.  In fact, that is the default behavior.  The single attribute value
for all vertices can be
set using the family of functions <i>gl.vertexAttrib*</i>, which work similarly to
<i>gl.uniform*</i>.  In the more usual case, where you want to take the values of an attribute from a VBO,
you must enable the use of a VBO for that attribute.  This is done by calling</p>

<pre>gl.enableVertexAttribArray( colorAttribLoc );</pre>

<np>where the parameter is the location of the attribute in the shader program, as returned
by a call to <i>gl.getAttribLocation</i>().   This command has nothing
to do with any particular VBO.  It just turns on the use of buffers for the specified attribute.
Often, it is reasonable to call this method just once, during initialization.
Use of data from the VBO can be turned off by calling
</np>

<pre>gl.disableVertexAttribArray( colorAttribLoc );</pre>

<p>Finally, before you draw a primitive that uses the attribute data from a VBO, you have to tell WebGL which buffer 
contains the data and how the bits in that buffer are to be interpreted.  This is done with 
<i>gl.vertexAttribPointer</i>().  The VBO must be bound to the <i>ARRAY_BUFFER</i> target when
this function is called.  For example,</p>

<pre>gl.bindBuffer( gl.ARRAY_BUFFER, colorBuffer );
gl.vertexAttribPointer( colorAttribLoc, 3, gl.FLOAT, false, 0, 0 );</pre>

<np>Assuming that <i>colorBuffer</i> refers to the VBO and <i>colorAttribLoc</i> is
the location of the attribute, this tells WebGL to take values for
the attribute from that buffer.  Often, you will call <i>gl.bindBuffer</i>() just before calling
<i>gl.vertexAttribPointer</i>(), but that is not necessary if the desired buffer is already bound. </np>

<p>The first parameter to <i>gl.vertexAttribPointer</i> is the attribute location.  
The second is the number of values per vertex.  For example, if you are providing values 
for a <i>vec2</i>, the second parameter will be 2 and
you will provide two numbers per vertex; for a <i>vec3</i>, the second parameter would be 3;
for a <i>float</i>, it would be&nbsp;1.  The third parameter specifies the type of each value.
Here, <i>gl.FLOAT</i> indicates that each value is a 32-bit floating point number.  Other values
include <i>gl.BYTE</i>, <i>gl.UNSIGNED_BYTE</i>, <i>gl.UNSIGNED_SHORT</i>,
and <i>gl.SHORT</i> for integer values.  Note that in WebGL&nbsp;1.0, all attributes
are floating point values; if you provide integer values for an attribute, they will be
converted to floating point.  The parameter value should
match the data type in the buffer.  For example, if the data came from a <classname>Float32Array</classname>,
then the parameter should be <i>gl.FLOAT</i>.
For the last three parameters in a call to <i>gl.vertexAttribPointer</i>, 
I will always use <i>false</i>, 0, and&nbsp;0.
These parameters add flexibility that I won't need; you can look them up in the documentation
if you are interested.  (The <i>false</i> parameter has to do with how integer values are converted
into floating point values.)</p>

<p><b>In WebGL 2.0</b>, attribute variables can have integer type.  When
<i>gl.vertexAttribPointer</i>() is used to configure an attribute, the values provided for the attribute
will always be converted to floating point, so it is inappropriate for integer-valued attributes.
For use with integer-valued attributes, WebGL 2.0
introduces a new function, <i>gl.vertexAttribIPointer</i>() that works correctly with
integer data.</p>

<p>There is a lot to take in here.  Using a VBO to provide values for an attribute requires
six separate commands, and that is in addition to generating the data and placing it in
a typed array.  Here is the full set of commands:</p>

<pre>colorAttribLoc = gl.getAttribLocation( prog, "a_color" );
colorBuffer = gl.createBuffer();
gl.enableVertexAttribArray( colorAttribLoc );

gl.bindBuffer( gl.ARRAY_BUFFER, colorBuffer );
gl.vertexAttribPointer( colorAttribLoc, 3, gl.FLOAT, false, 0, 0 );
gl.bufferData( gl.ARRAY_BUFFER, colorArray, gl.STATIC_DRAW );</pre>

<np>However, the six commands will not always occur at the same point in the JavaScript
code.  The first three commands are often done as part of initialization.  
<i>gl.bufferData</i> would be called whenever the data for the attribute needs to be changed;
it might be used just once during initialization, or it might be used whenever the data
needs to be modified.
<i>gl.bindBuffer</i> must be called before <i>gl.vertexAttribPointer</i>
or <i>gl.bufferData</i>, since it establishes the VBO that is used by those
two commands.  Remember that all of this must be done for every attribute that is
used in the shader program.</np>


</subsection>


<subsection title="Drawing a Primitive" id="webgl.1.6">

<p>After the shader program has been created and values have been set up for the uniform
variables and attributes, it takes just one more command to draw a primitive. One way to
do that is with the function <i>gl.drawArrays</i>:</p>

<pre>gl.drawArrays( primitiveType, startVertex, vertexCount );</pre>

<np>The first parameter is one of the seven constants that identify WebGL primitive types,
such as <i>gl.TRIANGLES</i>, <i>gl.LINE_LOOP</i>, and <i>gl_POINTS</i>.  The second
and third parameters are integers that determine which subset of available vertices is used for the primitive.
Before calling <i>gl.drawArrays</i>, you will have placed attribute values for some number of vertices
into one or more VBOs.  When the primitive is rendered, the attribute values for enabled attributes are pulled from the
VBOs.  The <i>startVertex</i> is the starting vertex number of the data within the VBOs,
and <i>vertexCount</i> is the number of vertices in the primitive.  Often, <i>startVertex</i>
is zero, and <i>vertexCount</i> is the total number of vertices for which data is available.
For example, the command for drawing a single triangle might be</np>

<pre>gl.drawArrays( gl.TRIANGLES, 0, 3 );</pre>

<p>The use of the word "array" in <i>gl.drawArrays</i> and <i>gl.ARRAY_BUFFER</i> might be a little
confusing, since the data is stored in vertex buffer objects rather than in JavaScript arrays.
When <i>glDrawArrays</i> was first introduced in OpenGL&nbsp;1.1, it used ordinary arrays rather
than VBOs.  Starting with OpenGL 1.5, <i>glDrawArrays</i> could be used either with ordinary arrays
or VBOs.  In WebGL, support for ordinary arrays was dropped, and <i>gl.drawArrays</i> can only
work with VBOs, even though the name still refers to arrays.</p>

<p>We encountered the original version of <i>glDrawArrays</i> in <localref href="gl1geom.4.2"/>.
That section also introduced an alternative function for drawing primitives, <i>glDrawElements</i>,
which can be used for drawing indexed face sets.  A <i>gl.drawElements</i> function is also available
in WebGL.  With <i>gl.drawElements</i>, attribute data is not used in the order in which it occurs in 
the VBOs.  Instead, there is a separate list of indices that determines the order in which
the data is accessed.</p>

<p>To use <i>gl.drawElements</i>, an extra VBO is required to hold the list of indices.
When used for this purpose, the VBO must be bound to the target <i>gl.ELEMENT_ARRAY_BUFFER</i>
rather than <i>gl.ARRAY_BUFFER</i>.   The VBO will hold integer values, which can be of type 
<i>gl.UNSIGNED_BYTE</i> or <i>gl.UNSIGNED_SHORT</i> (or, for WebGL&nbsp;2.0, <i>gl.UNSIGNED_INT</i>).  
The values can be loaded from
a JavaScript typed array of type <classname>Uint8Array</classname>, for <i>gl.UNSIGNED_BYTE</i>,
or <classname>Uint16Array</classname>, for <i>gl.UNSIGNED_SHORT</i>.
Creating the VBO and filling it with data is again a multistep process.  For example,
</p>

<pre>elementBuffer = gl.createBuffer();
gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
let data = new Uint8Array( [ 2,0,3, 2,1,3, 1,4,3 ] );
gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, data, gl.STREAM_DRAW );</pre>

<np>Assuming that the attribute data has also been loaded into VBOs, <i>gl.drawElements</i> can then be used
to draw the primitive.  A call to <i>gl.drawElements</i> takes the form</np>

<pre>gl.drawElements( primitiveType, count, dataType, startByte );</pre>

<np>The VBO that contains the vertex indices must be bound to the <i>ELEMENT_ARRAY_BUFFER</i> target
when this function is called.
The first parameter to <i>gl.drawElements</i>
is a primitive type such as <i>gl.TRIANGLE_FAN</i>.  The <i>count</i>
is the number of vertices in the primitive.  The <i>dataType</i> specifies the type
of data that was loaded into the VBO; it will be either <i>gl.UNSIGNED_SHORT</i>
or <i>gl.UNSIGNED_BYTE</i>.  The <i>startByte</i> is the starting point in the VBO of
the data for the primitive; it is usually zero.  (Note that the starting point is given
in terms of bytes, not vertex numbers.) A typical example would be</np>

<pre>gl.drawElements( gl.TRIANGLES, 9, gl.UNSIGNED_BYTE, 0 );</pre>

<p>We will have occasion to use this function later.  If you find it confusing, you should
review <localref href="gl1geom.4.2"/>.  The situation is much the same in WebGL as it was
in OpenGL&nbsp;1.1.</p>

</subsection>


<subsection title="WebGL 2.0: Vertex Array Objects" id="webgl.1.7">

<p>The large number of functions needed to work with attributes can seem excessive.
The situation is worse in a program that draws several different objects.  Each object can
require its own buffers and its own settings for attribute pointers.
Before drawing each object, it would be necessary to call <i>gl.bindBuffer</i>()
and <i>gl.vertexAttribPointer</i>() for each attribute. A typical 3D graphics program
would use attributes for vertex coordinates, normal vectors, material properties, and
texture coordinates.  So, there would be a lot of function calls for each object.</p>

<p>To help with this situation, WebGL 2.0 introduced <newword term="VAO">Vertex Array Objects</newword> (VAOs).
A VAO is a section of memory, typically stored on the graphics card.  It holds settings
that are used by rendering functions such as <i>gl.drawArrays</i>().  This includes the 
enabled state of each attribute, references to the buffers used for the attribute data,
and the values of all properties that are set by calling <i>gl.vertexAttribPointer</i>().
It also includes the settings and a reference to the buffer used by <i>gl.drawElements()</i>,
as well as the attribute divisors that are discussed in the next subsection.</p>

<p>WebGL 2.0 has a default VAO, which it uses when no other VAO has been selected.
To use an alternative VAO, you first have to create it, by calling <i>gl.createVertexArray</i>():</p>

<pre>vao = gl.createVertexArray();</pre>

<np>The return value, <i>vao</i>, is an identifier for the VAO that has been created.
In the new VAO, all properties have their default values.  In particular, all vertex
attributes are disabled and have no associated buffers.
To actually use a VAO, you need to bind it:</np>

<pre>gl.bindVertexArray(vao);</pre>

<np>Functions that affect or use attributes apply to the VAO that is currently bound.
For example, the settings in a call to <i>gl.vertexAttribPointer</i>() are stored
in the current VAO.  And a call to <i>gl.drawArrays</i>() gets all the data that
it needs to draw a primitive from the current VAO.  A program can switch from one
VAO to another at any time simply by calling <i>gl.bindVertexArray</i>.  To go 
back to using the default VAO, a program can call <i>gl.bindVertexArray</i>(0).</np>

<p>The idea is that a program that draws several objects can use a different
VAO for each object.  The VAO for an object must be bound when the settings for
the object are configured.
But before drawing the object, the program simply needs to
bind the VAO for that object.  That single function call replaces a potentially
a large number of function calls that would be needed to restore the appropriate settings for each attribute
individually.  The advantage is more than just a more nicely organized program&mdash;it
is also much more efficient, since only one command needs to be sent to the GPU
to configure all of the attributes.</p>

<p>The sample WebGL 2.0 program <sourceref href="webgl/VAO-test-webgl2.html"/> uses a
different VAO for each of six different objects.  That program uses many
techniques that we have not yet covered, but you can look at the
<i>drawModel</i>() function to see how it uses VAOs and VBOs.</p>

</subsection>


<subsection title="WebGL 2.0: Instanced Drawing" id="webgl.1.8">

<p>It's common for a scene to contain multiple copies of the same
primitive (that is, using the same vertex coordinates), but with
different transformations, colors, or other properties for each
copy. WebGL&nbsp;2.0 makes it possible to draw all those copies
with a single function call.  This is called <newword>instanced drawing</newword>
or instancing, and the individual copies of the primitive are called instances.
The functions that use instanced drawing are
<i>gl.drawArraysInstanced</i>() and <i>gl.drawElementsInstanced</i>().</p>

<p>Instanced properties&mdash;the properties that vary from one instance to another&mdash;are things
that would likely be uniform variables when drawing each instance separately.
That is, each instance gets just one value of the property that applies
to all the vertices of the instance.  Nevertheless, the properties
are represented by attribute variables in the shader program, not uniform
variables, and they are configured as attributes.</p>

<p>To specify that an attribute is an instanced property, you just need to
specify a "divisor" for that attribute.  This is done by calling
<i>gl.vertexAttribDivisor</i>:</p>

<pre>g.vertexAttribDivisor( attribID, divisor );</pre>

<np>Here, <i>attribID</i> is the identifier for the attribute, as returned by
<i>gl.getAttribLocation</i>().  The <i>divisor</i> is a non-negative integer.
Passing zero as the divisor will turn off instancing for the attribute.
If <i>divisor</i> is positive, then each value of the attribute will apply
to that many instances.  For example, if <i>divisor</i> is 3, then the
first entry in the attribute value array applies to the first, second, and
third instances; the second value in the array applies to the fourth, fifth,
and sixth instances; and so on.  In practice, the value of <i>divisor</i>
is usually one, meaning that each instance has its own entry in the
attribute value array.</np>

<p>For an instanced property, in addition to setting the divisor, it is still
necessary to enable the attribute, load data for it into a VBO, and
configure it with <i>gl.vertexAttribPointer</i>.  And, of course, it is
necessary to draw the primitive using <i>gl.drawArraysInstanced</i>()
or <i>gl.drawElementsInstanced</i>(), and not with <i>gl.drawArrays</i>()
or <i>gl.drawElements()</i>.</p>

<p>The sample WebGL 2.0 program <sourceref href="webgl/instancing-test-webgl2.html"/> 
is an example of instanced drawing.  (Again, there is a lot in the program
that you won't understand until we have covered more of WebGL).  The
program draws 30 colored disks, where a disk is approximated by
a primitive of type <i>gl.TRIANGLE_FAN</i>.  Three attributes are used:
an attribute that holds the coordinates of the vertices, an
instanced attribute that holds the colors for the disks, and
an instanced attribute that holds a different translation for
each disk.</p>

<p>Another point of interest in the program is its used of vertex buffer objects.
The disks can be animated.  The disks move, but their colors don't change.
Since the colors don't change, the color values for the disks are loaded
into a VBO once, during program initialization.  The usage parameter in
<i>gl.bufferData</i> is set to <i>gl.STATIC_DRAW</i> because the 
data will not be modified.  However, because the disks are moving, the values for
the translations of the disks have to change in each frame.
So, new data is loaded into the corresponding VBO for each frame, with
usage <i>gl.STREAM_DRAW</i> because the data that is being loaded will
only be used once.</p>

<p>Finally, I should note that VAOs and instancing require WebGL 2.0,
but the same functionality is available in many implementations of 
WebGL 1.0 as optional extensions.  Webgl extensions will be discussed
in <localref href="webgl3d.5"></localref>.</p>


</subsection>





</section>
